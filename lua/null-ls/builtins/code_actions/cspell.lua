local h = require("null-ls.helpers")
local methods = require("null-ls.methods")

local CODE_ACTION = methods.internal.CODE_ACTION
-- filter diagnostics generated by the cspell built-in
local cspell_diagnostics = function(bufnr, lnum, cursor_col)
    local diagnostics = {}
    for _, diagnostic in ipairs(vim.diagnostic.get(bufnr, { lnum = lnum })) do
        if diagnostic.source == "cspell" and cursor_col >= diagnostic.col and cursor_col < diagnostic.end_col then
            table.insert(diagnostics, diagnostic)
        end
    end
    return diagnostics
end

local CSPELL_CONFIG_FILES = {
    "cspell.json",
    ".cspell.json",
    "cSpell.json",
    ".Sspell.json",
    ".cspell.config.json",
}

-- find the first cspell.json file in the directory tree
local find_cspell_config_path = function(cwd)
    local cspell_json_path = nil
    for _, file in ipairs(CSPELL_CONFIG_FILES) do
        local path = vim.fn.findfile(file, (cwd or vim.loop.cwd()) .. ";")
        if path ~= "" then
            cspell_json_path = path
            break
        end
    end
    return cspell_json_path
end

-- create a bare minimum cspell.json file
local create_cspell_json = function(cwd, file_name)
    local cspell_json = {
        version = "0.2",
        language = "en",
        words = {},
        flagWords = {},
    }
    local cspell_json_str = vim.json.encode(cspell_json)
    local cspell_json_file_path = require("null-ls.utils").path.join(cwd or vim.loop.cwd(), file_name)
    vim.fn.writefile({ cspell_json_str }, cspell_json_file_path)
    vim.notify("Created a new cspell.json file at " .. cspell_json_file_path, vim.log.levels.INFO)
    return cspell_json_file_path
end

local get_word = function(diagnostic)
    return vim.api.nvim_buf_get_text(
        diagnostic.bufnr,
        diagnostic.lnum,
        diagnostic.col,
        diagnostic.end_lnum,
        diagnostic.end_col,
        {}
    )[1]
end

return h.make_builtin({
    name = "cspell",
    meta = {
        url = "https://github.com/streetsidesoftware/cspell",
        description = "Injects actions to fix typos found by `cspell`.",
        notes = {
            "This source depends on the `cspell` built-in diagnostics source, so make sure to register it, too.",
        },
        usage = "local sources = { null_ls.builtins.diagnostics.cspell, null_ls.builtins.code_actions.cspell }",
    },
    method = CODE_ACTION,
    filetypes = {},
    generator = {
        fn = function(params)
            local actions = {}
            local config = params:get_config()
            local find_json = config.find_json or find_cspell_config_path

            -- create_config_file if nil defaults to true
            local create_config_file = config.create_config_file ~= false

            local create_config_file_name = config.create_config_file_name or "cspell.json"
            if not vim.tbl_contains(CSPELL_CONFIG_FILES, create_config_file_name) then
                vim.notify(
                    "Invalid default file name for cspell json file: "
                        .. create_config_file_name
                        .. '. The name "cspell.json" will be used instead',
                    vim.log.levels.WARN
                )
                create_config_file_name = "cspell.json"
            end

            ---@return table|nil cspell, string|nil cspell_json_path
            local get_or_create_cspell_config = function()
                local cspell_json_path = find_json(params.cwd)
                    or (create_config_file and create_cspell_json(params.cwd, create_config_file_name))
                    or nil

                if cspell_json_path == nil or cspell_json_path == "" then
                    vim.notify("\nNo cspell json file found in the directory tree.\n", vim.log.levels.WARN)
                    return
                end

                local ok, cspell = pcall(vim.json.decode, table.concat(vim.fn.readfile(cspell_json_path), " "))

                if not ok then
                    vim.notify("\nCannot parse cspell json file as JSON.\n", vim.log.levels.ERROR)
                    return
                end

                return cspell, cspell_json_path
            end

            local diagnostics = cspell_diagnostics(params.bufnr, params.row - 1, params.col)
            if vim.tbl_isempty(diagnostics) then
                return nil
            end
            for _, diagnostic in ipairs(diagnostics) do
                for _, suggestion in ipairs(diagnostic.user_data.suggestions) do
                    table.insert(actions, {
                        title = string.format("Use %s", suggestion),
                        action = function()
                            vim.api.nvim_buf_set_text(
                                diagnostic.bufnr,
                                diagnostic.lnum,
                                diagnostic.col,
                                diagnostic.end_lnum,
                                diagnostic.end_col,
                                { suggestion }
                            )
                        end,
                    })
                end

                -- add word to "words" in cspell.json
                table.insert(actions, {
                    title = "Add to cspell json file",
                    action = function()
                        local cspell, cspell_json_path = get_or_create_cspell_config()
                        if cspell == nil or cspell_json_path == nil then
                            return
                        end

                        if not cspell.words then
                            cspell.words = {}
                        end

                        local word = get_word(diagnostic)

                        table.insert(cspell.words, word)

                        vim.fn.writefile({ vim.json.encode(cspell) }, cspell_json_path)

                        -- replace word in buffer to trigger cspell to update diagnostics
                        vim.api.nvim_buf_set_text(
                            diagnostic.bufnr,
                            diagnostic.lnum,
                            diagnostic.col,
                            diagnostic.end_lnum,
                            diagnostic.end_col,
                            { word }
                        )
                    end,
                })

                table.insert(actions, {
                    title = "Add to a custom dictionary",
                    action = function()
                        local cspell = get_or_create_cspell_config()
                        if cspell == nil then
                            return
                        end

                        local options = vim.tbl_filter(function(definition)
                            return definition.addWords
                        end, cspell.dictionaryDefinitions or {})

                        if vim.tbl_isempty(options) then
                            vim.notify(
                                "There are no custom dictionaries.\nFor details, see: https://cspell.org/docs/dictionaries-custom/",
                                vim.log.levels.WARN
                            )
                            return
                        end
                        local word = get_word(diagnostic)

                        local custom_dictionary_options = {
                            prompt = 'Add "' .. word .. '" to a custom dictionary',
                            format_item = function(definition)
                                return definition.name .. " - " .. definition.path
                            end,
                        }

                        local custom_dictionary_action = function(definition)
                            if definition == nil then
                                return
                            end
                            local dictionary_path = vim.fn.expand(definition.path)
                            local dictionary_ok, dictionary_body = pcall(vim.fn.readfile, dictionary_path)
                            if not dictionary_ok then
                                vim.notify("Can't read " .. dictionary_path, vim.log.levels.ERROR)
                                return
                            end
                            table.insert(dictionary_body, word)

                            vim.fn.writefile(dictionary_body, dictionary_path)
                            vim.notify('Added "' .. word .. '" to ' .. definition.path, vim.log.levels.INFO)
                        end

                        vim.ui.select(options, custom_dictionary_options, custom_dictionary_action)
                    end,
                })
            end
            return actions
        end,
    },
})
